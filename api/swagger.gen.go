// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// Base defines model for Base.
type Base struct {
	Version *string `json:"version,omitempty"`
}

// ComingShoppingsProperty defines model for ComingShoppingsProperty.
type ComingShoppingsProperty struct {
	Validation *ComingShoppingsValidation `json:"validation,omitempty"`
}

// ComingShoppingsValidation defines model for ComingShoppingsValidation.
type ComingShoppingsValidation struct {
	Date *string `json:"date,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Embedded struct due to allOf(#/components/schemas/Base)
	Base
	// Embedded fields due to inline allOf schema
	Data interface{} `json:"data"`
}

// Error400 defines model for Error_400.
type Error400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors  []interface{} `json:"errors"`
	Message string        `json:"message"`
}

// Error401 defines model for Error_401.
type Error401 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors  []interface{} `json:"errors"`
	Message string        `json:"message"`
}

// Error404 defines model for Error_404.
type Error404 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors  []interface{} `json:"errors"`
	Message string        `json:"message"`
}

// Error405 defines model for Error_405.
type Error405 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors  *[]interface{} `json:"errors,omitempty"`
	Message *string        `json:"message,omitempty"`
}

// Error500 defines model for Error_500.
type Error500 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors  interface{} `json:"errors"`
	Message string      `json:"message"`
}

// Shopping defines model for Shopping.
type Shopping struct {
	// Embedded fields due to inline allOf schema
	// Embedded struct due to allOf(#/components/schemas/Shopping_params)
	ShoppingParams
}

// ShoppingProperty defines model for ShoppingProperty.
type ShoppingProperty struct {
	Validation *ShoppingValidation `json:"validation,omitempty"`
}

// ShoppingValidation defines model for ShoppingValidation.
type ShoppingValidation struct {
	Date    *string `json:"date,omitempty"`
	Name    *int    `json:"name,omitempty"`
	OwnerID *int    `json:"ownerID,omitempty"`
	Time    *string `json:"time,omitempty"`
}

// ShoppingItem defines model for Shopping_item.
type ShoppingItem struct {
	// Embedded fields due to inline allOf schema
	// Embedded struct due to allOf(#/components/schemas/shoppingItemParamsWithId)
	ShoppingItemParamsWithId
}

// ShoppingParams defines model for Shopping_params.
type ShoppingParams struct {
	Date    string `json:"date"`
	Name    string `json:"name"`
	OwnerID int    `json:"ownerID"`
	Time    string `json:"time"`
}

// ShoppingWithId defines model for Shopping_with_id.
type ShoppingWithId struct {
	// Embedded fields due to inline allOf schema
	// Embedded fields due to inline allOf schema
	Id *int `json:"id,omitempty"`
	// Embedded struct due to allOf(#/components/schemas/Shopping_params)
	ShoppingParams
}

// Success defines model for Success.
type Success struct {
	// Embedded struct due to allOf(#/components/schemas/Base)
	Base
	// Embedded fields due to inline allOf schema
	Errors  []interface{} `json:"errors"`
	Message string        `json:"message"`
}

// ShoppingDaysErrors defines model for shoppingDaysErrors.
type ShoppingDaysErrors struct {
	Validation *ShoppingDaysValidation `json:"validation,omitempty"`
}

// ShoppingDaysValidation defines model for shoppingDaysValidation.
type ShoppingDaysValidation struct {
	Month *string `json:"month,omitempty"`
	Year  *string `json:"year,omitempty"`
}

// ShoppingItemParams defines model for shoppingItemParams.
type ShoppingItemParams struct {
	CategoryID  int    `json:"categoryID"`
	Complete    bool   `json:"complete"`
	ListID      int    `json:"listID"`
	ProductName string `json:"productName"`
	Quantity    int    `json:"quantity"`
}

// ShoppingItemParamsWithId defines model for shoppingItemParamsWithId.
type ShoppingItemParamsWithId struct {
	// Embedded fields due to inline allOf schema
	Id *int `json:"id,omitempty"`
	// Embedded struct due to allOf(#/components/schemas/shoppingItemParams)
	ShoppingItemParams
	// Embedded fields due to inline allOf schema
}

// Date defines model for date.
type Date string

// Month defines model for month.
type Month int

// ShoppingID defines model for shoppingID.
type ShoppingID int

// Token defines model for token.
type Token string

// Year defines model for year.
type Year int

// Base401 defines model for Base_401.
type Base401 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_401)
	Error401
}

// Base404 defines model for Base_404.
type Base404 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_404)
	Error404
}

// Base405 defines model for Base_405.
type Base405 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_405)
	Error405
}

// Base500 defines model for Base_500.
type Base500 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_500)
	Error500
}

// ComingShoppings200 defines model for ComingShoppings_200.
type ComingShoppings200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]ShoppingWithId `json:"data,omitempty"`
}

// ComingShoppings400 defines model for ComingShoppings_400.
type ComingShoppings400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	Errors *ComingShoppingsProperty `json:"errors,omitempty"`
}

// Goods200 defines model for Goods_200.
type Goods200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]ShoppingItem `json:"data,omitempty"`
}

// Goods400 defines model for Goods_400.
type Goods400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	Errors *struct {
		Validation *struct {
			ShoppingID *string `json:"shoppingID,omitempty"`
		} `json:"validation,omitempty"`
	} `json:"errors,omitempty"`
}

// Item200 defines model for Item_200.
type Item200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]ShoppingItemParamsWithId `json:"data,omitempty"`
}

// Item400 defines model for Item_400.
type Item400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	Errors *struct {
		Validation *struct {
			CategoryID  *int    `json:"categoryID,omitempty"`
			ListID      *int    `json:"listID,omitempty"`
			ProductName *string `json:"productName,omitempty"`
			Quantity    *int    `json:"quantity,omitempty"`
		} `json:"validation,omitempty"`
	} `json:"errors,omitempty"`
}

// LastShopping200 defines model for LastShopping_200.
type LastShopping200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]ShoppingWithId `json:"data,omitempty"`
}

// ShoppingDays200 defines model for ShoppingDays_200.
type ShoppingDays200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]int `json:"data,omitempty"`
}

// ShoppingDays400 defines model for ShoppingDays_400.
type ShoppingDays400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	Errors *ShoppingDaysErrors `json:"errors,omitempty"`
}

// Shopping200 defines model for Shopping_200.
type Shopping200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]ShoppingWithId `json:"data,omitempty"`
}

// Shopping400 defines model for Shopping_400.
type Shopping400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	Errors *ShoppingProperty `json:"errors,omitempty"`
}

// ItemRequest defines model for Item_request.
type ItemRequest struct {
	// Embedded struct due to allOf(#/components/schemas/shoppingItemParams)
	ShoppingItemParams
}

// ShoppingRequest defines model for Shopping_request.
type ShoppingRequest struct {
	// Embedded struct due to allOf(#/components/schemas/Shopping)
	Shopping
}

// AddItemParams defines parameters for AddItem.
type AddItemParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// AddShoppingParams defines parameters for AddShopping.
type AddShoppingParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// GetComingShoppingsParams defines parameters for GetComingShoppings.
type GetComingShoppingsParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// GetGoodsParams defines parameters for GetGoods.
type GetGoodsParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// GetShoppingDaysParams defines parameters for GetShoppingDays.
type GetShoppingDaysParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// LastShoppingParams defines parameters for LastShopping.
type LastShoppingParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// AddItemRequestBody defines body for AddItem for application/json ContentType.
type AddItemJSONRequestBody ItemRequest

// AddShoppingRequestBody defines body for AddShopping for application/json ContentType.
type AddShoppingJSONRequestBody ShoppingRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Добавление товара в покупку// (POST /addItem)
	AddItem(ctx echo.Context, params AddItemParams) error
	// Добавление покупки// (POST /addShopping)
	AddShopping(ctx echo.Context, params AddShoppingParams) error
	// Ближайшие 5 покупок// (GET /getComingShoppings/{date})
	GetComingShoppings(ctx echo.Context, date Date, params GetComingShoppingsParams) error
	// Список покупок// (GET /getGoods/{shoppingID})
	GetGoods(ctx echo.Context, shoppingID ShoppingID, params GetGoodsParams) error
	// Получение списка дней с покупками по месяцу и году// (GET /getShoppingDays/{year}/{month})
	GetShoppingDays(ctx echo.Context, year Year, month Month, params GetShoppingDaysParams) error
	// Последняя покупка// (GET /lastShopping)
	LastShopping(ctx echo.Context, params LastShoppingParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AddItem converts echo context to params.
func (w *ServerInterfaceWrapper) AddItem(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AddItemParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddItem(ctx, params)
	return err
}

// AddShopping converts echo context to params.
func (w *ServerInterfaceWrapper) AddShopping(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AddShoppingParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddShopping(ctx, params)
	return err
}

// GetComingShoppings converts echo context to params.
func (w *ServerInterfaceWrapper) GetComingShoppings(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "date" -------------
	var date Date

	err = runtime.BindStyledParameter("simple", false, "date", ctx.Param("date"), &date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComingShoppingsParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetComingShoppings(ctx, date, params)
	return err
}

// GetGoods converts echo context to params.
func (w *ServerInterfaceWrapper) GetGoods(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "shoppingID" -------------
	var shoppingID ShoppingID

	err = runtime.BindStyledParameter("simple", false, "shoppingID", ctx.Param("shoppingID"), &shoppingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shoppingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGoodsParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGoods(ctx, shoppingID, params)
	return err
}

// GetShoppingDays converts echo context to params.
func (w *ServerInterfaceWrapper) GetShoppingDays(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "year" -------------
	var year Year

	err = runtime.BindStyledParameter("simple", false, "year", ctx.Param("year"), &year)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter year: %s", err))
	}

	// ------------- Path parameter "month" -------------
	var month Month

	err = runtime.BindStyledParameter("simple", false, "month", ctx.Param("month"), &month)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter month: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShoppingDaysParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetShoppingDays(ctx, year, month, params)
	return err
}

// LastShopping converts echo context to params.
func (w *ServerInterfaceWrapper) LastShopping(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params LastShoppingParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LastShopping(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/addItem", wrapper.AddItem)
	router.POST("/addShopping", wrapper.AddShopping)
	router.GET("/getComingShoppings/:date", wrapper.GetComingShoppings)
	router.GET("/getGoods/:shoppingID", wrapper.GetGoods)
	router.GET("/getShoppingDays/:year/:month", wrapper.GetShoppingDays)
	router.GET("/lastShopping", wrapper.LastShopping)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

