// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// Base defines model for Base.
type Base struct {

	// Вeрсия ответа сервиса
	Version *string `json:"version,omitempty"`
}

// ComingShoppingsProperty defines model for ComingShoppingsProperty.
type ComingShoppingsProperty struct {
	Validation *ComingShoppingsValidation `json:"validation,omitempty"`
}

// ComingShoppingsValidation defines model for ComingShoppingsValidation.
type ComingShoppingsValidation struct {
	Date *string `json:"date,omitempty"`
}

// DeleteIds defines model for Delete_ids.
type DeleteIds struct {

	// Массив идентификаторв для удаления
	Ids []int `json:"ids"`
}

// Error defines model for Error.
type Error struct {
	// Embedded struct due to allOf(#/components/schemas/Base)
	Base
	// Embedded fields due to inline allOf schema
	Data interface{} `json:"data"`
}

// Error400 defines model for Error_400.
type Error400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors  []interface{} `json:"errors"`
	Message string        `json:"message"`
}

// Error401 defines model for Error_401.
type Error401 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors  []interface{} `json:"errors"`
	Message string        `json:"message"`
}

// Error404 defines model for Error_404.
type Error404 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors []interface{} `json:"errors"`

	// сообщение об ошибке
	Message string `json:"message"`
}

// Error405 defines model for Error_405.
type Error405 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors *[]interface{} `json:"errors,omitempty"`

	// сообщение ответа
	Message *string `json:"message,omitempty"`
}

// Error500 defines model for Error_500.
type Error500 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors interface{} `json:"errors"`

	// сообщение ответа
	Message string `json:"message"`
}

// Shopping defines model for Shopping.
type Shopping struct {
	// Embedded fields due to inline allOf schema
	// Embedded struct due to allOf(#/components/schemas/Shopping_params)
	ShoppingParams
}

// ShoppingProperty defines model for ShoppingProperty.
type ShoppingProperty struct {
	Validation *ShoppingValidation `json:"validation,omitempty"`
}

// ShoppingValidation defines model for ShoppingValidation.
type ShoppingValidation struct {
	Date    *string `json:"date,omitempty"`
	Name    *int    `json:"name,omitempty"`
	OwnerID *int    `json:"ownerID,omitempty"`
	Time    *string `json:"time,omitempty"`
}

// ShoppingItem defines model for Shopping_item.
type ShoppingItem struct {
	// Embedded fields due to inline allOf schema
	// Embedded struct due to allOf(#/components/schemas/shoppingItemParamsWithId)
	ShoppingItemParamsWithId
}

// ShoppingParams defines model for Shopping_params.
type ShoppingParams struct {

	// Дата покупки
	Date string `json:"date"`

	// Наименование магазина
	Name string `json:"name"`

	// Владелец покупки
	OwnerID int `json:"ownerID"`

	// Время совершения покупки
	Time string `json:"time"`
}

// ShoppingWithId defines model for Shopping_with_id.
type ShoppingWithId struct {
	// Embedded fields due to inline allOf schema
	// Embedded fields due to inline allOf schema

	// Идентификатор покупки
	Id *int `json:"id,omitempty"`
	// Embedded struct due to allOf(#/components/schemas/Shopping_params)
	ShoppingParams
}

// Success defines model for Success.
type Success struct {
	// Embedded struct due to allOf(#/components/schemas/Base)
	Base
	// Embedded fields due to inline allOf schema

	// Ошибки ответа
	Errors []interface{} `json:"errors"`

	// Сообщение ответа
	Message string `json:"message"`
}

// ShoppingDaysErrors defines model for shoppingDaysErrors.
type ShoppingDaysErrors struct {
	Validation *ShoppingDaysValidation `json:"validation,omitempty"`
}

// ShoppingDaysValidation defines model for shoppingDaysValidation.
type ShoppingDaysValidation struct {
	Month *string `json:"month,omitempty"`
	Year  *string `json:"year,omitempty"`
}

// ShoppingItemParams defines model for shoppingItemParams.
type ShoppingItemParams struct {

	// Идентификатор категории товара
	CategoryID int `json:"categoryID"`

	// Признак выполнения
	Complete bool `json:"complete"`

	// Идентификатор списка покупок
	ListID int `json:"listID"`

	// Наименование товара
	ProductName string `json:"productName"`

	// Количество товара
	Quantity int `json:"quantity"`
}

// ShoppingItemParamsWithId defines model for shoppingItemParamsWithId.
type ShoppingItemParamsWithId struct {
	// Embedded fields due to inline allOf schema

	// Идентификатор товара
	Id *int `json:"id,omitempty"`
	// Embedded struct due to allOf(#/components/schemas/shoppingItemParams)
	ShoppingItemParams
	// Embedded fields due to inline allOf schema
}

// ShoppingsByDayErrors defines model for shoppingsByDayErrors.
type ShoppingsByDayErrors struct {
	Validation *ShoppingsByDayValidation `json:"validation,omitempty"`
}

// ShoppingsByDayValidation defines model for shoppingsByDayValidation.
type ShoppingsByDayValidation struct {
	Day   *string `json:"day,omitempty"`
	Month *string `json:"month,omitempty"`
	Year  *string `json:"year,omitempty"`
}

// Date defines model for date.
type Date string

// Day defines model for day.
type Day int

// Month defines model for month.
type Month int

// ShoppingID defines model for shoppingID.
type ShoppingID int

// Token defines model for token.
type Token string

// Year defines model for year.
type Year int

// Base200 defines model for Base_200.
type Base200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
}

// Base400 defines model for Base_400.
type Base400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
}

// Base401 defines model for Base_401.
type Base401 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_401)
	Error401
}

// Base404 defines model for Base_404.
type Base404 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_404)
	Error404
}

// Base405 defines model for Base_405.
type Base405 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_405)
	Error405
}

// Base500 defines model for Base_500.
type Base500 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_500)
	Error500
}

// ComingShoppings200 defines model for ComingShoppings_200.
type ComingShoppings200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]ShoppingWithId `json:"data,omitempty"`
}

// ComingShoppings400 defines model for ComingShoppings_400.
type ComingShoppings400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema

	// Свойства ошибки валидации
	Errors *ComingShoppingsProperty `json:"errors,omitempty"`
}

// Goods200 defines model for Goods_200.
type Goods200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]ShoppingItem `json:"data,omitempty"`
}

// Goods400 defines model for Goods_400.
type Goods400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	Errors *struct {
		Validation *struct {
			ShoppingID *string `json:"shoppingID,omitempty"`
		} `json:"validation,omitempty"`
	} `json:"errors,omitempty"`
}

// Item200 defines model for Item_200.
type Item200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]ShoppingItemParamsWithId `json:"data,omitempty"`
}

// Item400 defines model for Item_400.
type Item400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	Errors *struct {
		Validation *struct {

			// Идентификатор категории товара
			CategoryID *int `json:"categoryID,omitempty"`

			// Идентификатор списка покупок
			ListID      *int    `json:"listID,omitempty"`
			ProductName *string `json:"productName,omitempty"`

			// Количество товара
			Quantity *int `json:"quantity,omitempty"`
		} `json:"validation,omitempty"`
	} `json:"errors,omitempty"`
}

// LastShopping200 defines model for LastShopping_200.
type LastShopping200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]ShoppingWithId `json:"data,omitempty"`
}

// ShoppingDays200 defines model for ShoppingDays_200.
type ShoppingDays200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]int `json:"data,omitempty"`
}

// ShoppingDays400 defines model for ShoppingDays_400.
type ShoppingDays400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	Errors *ShoppingDaysErrors `json:"errors,omitempty"`
}

// Shopping200 defines model for Shopping_200.
type Shopping200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *ShoppingWithId `json:"data,omitempty"`
}

// Shopping400 defines model for Shopping_400.
type Shopping400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	Errors *ShoppingProperty `json:"errors,omitempty"`
}

// Shoppings200 defines model for Shoppings_200.
type Shoppings200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]ShoppingWithId `json:"data,omitempty"`
}

// Shoppings400 defines model for Shoppings_400.
type Shoppings400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	Errors *ShoppingsByDayErrors `json:"errors,omitempty"`
}

// DeleteItemsRequest defines model for Delete_items_request.
type DeleteItemsRequest DeleteIds

// DeleteShoppingsRequest defines model for Delete_shoppings_request.
type DeleteShoppingsRequest DeleteIds

// ItemRequest defines model for Item_request.
type ItemRequest struct {
	// Embedded struct due to allOf(#/components/schemas/shoppingItemParams)
	ShoppingItemParams
}

// ShoppingRequest defines model for Shopping_request.
type ShoppingRequest struct {
	// Embedded struct due to allOf(#/components/schemas/Shopping)
	Shopping
}

// AddItemParams defines parameters for AddItem.
type AddItemParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// AddShoppingParams defines parameters for AddShopping.
type AddShoppingParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// DeleteItemsParams defines parameters for DeleteItems.
type DeleteItemsParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// DeleteShoppingsParams defines parameters for DeleteShoppings.
type DeleteShoppingsParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// GetComingShoppingsParams defines parameters for GetComingShoppings.
type GetComingShoppingsParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// GetGoodsParams defines parameters for GetGoods.
type GetGoodsParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// GetShoppingParams defines parameters for GetShopping.
type GetShoppingParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// GetShoppingDaysParams defines parameters for GetShoppingDays.
type GetShoppingDaysParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// GetShoppingsByDayParams defines parameters for GetShoppingsByDay.
type GetShoppingsByDayParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// LastShoppingParams defines parameters for LastShopping.
type LastShoppingParams struct {

	// Токен доступа
	Token Token `json:"token"`
}

// AddItemRequestBody defines body for AddItem for application/json ContentType.
type AddItemJSONRequestBody ItemRequest

// AddShoppingRequestBody defines body for AddShopping for application/json ContentType.
type AddShoppingJSONRequestBody ShoppingRequest

// DeleteItemsRequestBody defines body for DeleteItems for application/json ContentType.
type DeleteItemsJSONRequestBody DeleteItemsRequest

// DeleteShoppingsRequestBody defines body for DeleteShoppings for application/json ContentType.
type DeleteShoppingsJSONRequestBody DeleteShoppingsRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Добавление товара в покупку
	// (POST /addItem)
	AddItem(ctx echo.Context, params AddItemParams) error
	// Добавление покупки
	// (POST /addShopping)
	AddShopping(ctx echo.Context, params AddShoppingParams) error
	// Удаление товаров
	// (DELETE /deleteItems)
	DeleteItems(ctx echo.Context, params DeleteItemsParams) error
	// Удаление покупок
	// (DELETE /deleteShoppings)
	DeleteShoppings(ctx echo.Context, params DeleteShoppingsParams) error
	// Ближайшие 5 покупок
	// (GET /getComingShoppings/{date})
	GetComingShoppings(ctx echo.Context, date Date, params GetComingShoppingsParams) error
	// Список покупок
	// (GET /getGoods/{shoppingID})
	GetGoods(ctx echo.Context, shoppingID ShoppingID, params GetGoodsParams) error
	// Даные покупки
	// (GET /getShopping/{shoppingID})
	GetShopping(ctx echo.Context, shoppingID ShoppingID, params GetShoppingParams) error
	// Получение списка дней с покупками по месяцу и году
	// (GET /getShoppingDays/{year}/{month})
	GetShoppingDays(ctx echo.Context, year Year, month Month, params GetShoppingDaysParams) error
	// Получение списка покупок по конекретному дню
	// (GET /getShoppingsByDay/{year}/{month}/{day})
	GetShoppingsByDay(ctx echo.Context, year Year, month Month, day Day, params GetShoppingsByDayParams) error
	// Последняя покупка
	// (GET /lastShopping)
	LastShopping(ctx echo.Context, params LastShoppingParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AddItem converts echo context to params.
func (w *ServerInterfaceWrapper) AddItem(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AddItemParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddItem(ctx, params)
	return err
}

// AddShopping converts echo context to params.
func (w *ServerInterfaceWrapper) AddShopping(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AddShoppingParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddShopping(ctx, params)
	return err
}

// DeleteItems converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteItems(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteItemsParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteItems(ctx, params)
	return err
}

// DeleteShoppings converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteShoppings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteShoppingsParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteShoppings(ctx, params)
	return err
}

// GetComingShoppings converts echo context to params.
func (w *ServerInterfaceWrapper) GetComingShoppings(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "date" -------------
	var date Date

	err = runtime.BindStyledParameter("simple", false, "date", ctx.Param("date"), &date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComingShoppingsParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetComingShoppings(ctx, date, params)
	return err
}

// GetGoods converts echo context to params.
func (w *ServerInterfaceWrapper) GetGoods(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "shoppingID" -------------
	var shoppingID ShoppingID

	err = runtime.BindStyledParameter("simple", false, "shoppingID", ctx.Param("shoppingID"), &shoppingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shoppingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGoodsParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGoods(ctx, shoppingID, params)
	return err
}

// GetShopping converts echo context to params.
func (w *ServerInterfaceWrapper) GetShopping(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "shoppingID" -------------
	var shoppingID ShoppingID

	err = runtime.BindStyledParameter("simple", false, "shoppingID", ctx.Param("shoppingID"), &shoppingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shoppingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShoppingParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetShopping(ctx, shoppingID, params)
	return err
}

// GetShoppingDays converts echo context to params.
func (w *ServerInterfaceWrapper) GetShoppingDays(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "year" -------------
	var year Year

	err = runtime.BindStyledParameter("simple", false, "year", ctx.Param("year"), &year)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter year: %s", err))
	}

	// ------------- Path parameter "month" -------------
	var month Month

	err = runtime.BindStyledParameter("simple", false, "month", ctx.Param("month"), &month)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter month: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShoppingDaysParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetShoppingDays(ctx, year, month, params)
	return err
}

// GetShoppingsByDay converts echo context to params.
func (w *ServerInterfaceWrapper) GetShoppingsByDay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "year" -------------
	var year Year

	err = runtime.BindStyledParameter("simple", false, "year", ctx.Param("year"), &year)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter year: %s", err))
	}

	// ------------- Path parameter "month" -------------
	var month Month

	err = runtime.BindStyledParameter("simple", false, "month", ctx.Param("month"), &month)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter month: %s", err))
	}

	// ------------- Path parameter "day" -------------
	var day Day

	err = runtime.BindStyledParameter("simple", false, "day", ctx.Param("day"), &day)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter day: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShoppingsByDayParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetShoppingsByDay(ctx, year, month, day, params)
	return err
}

// LastShopping converts echo context to params.
func (w *ServerInterfaceWrapper) LastShopping(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params LastShoppingParams
	// ------------- Required query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument token is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LastShopping(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/addItem", wrapper.AddItem)
	router.POST("/addShopping", wrapper.AddShopping)
	router.DELETE("/deleteItems", wrapper.DeleteItems)
	router.DELETE("/deleteShoppings", wrapper.DeleteShoppings)
	router.GET("/getComingShoppings/:date", wrapper.GetComingShoppings)
	router.GET("/getGoods/:shoppingID", wrapper.GetGoods)
	router.GET("/getShopping/:shoppingID", wrapper.GetShopping)
	router.GET("/getShoppingDays/:year/:month", wrapper.GetShoppingDays)
	router.GET("/getShoppingsByDay/:year/:month/:day", wrapper.GetShoppingsByDay)
	router.GET("/lastShopping", wrapper.LastShopping)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

