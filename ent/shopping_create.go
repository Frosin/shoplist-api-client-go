// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"time"

	"github.com/Frosin/shoplist-api-client-go/ent/item"
	"github.com/Frosin/shoplist-api-client-go/ent/shop"
	"github.com/Frosin/shoplist-api-client-go/ent/shopping"
	"github.com/Frosin/shoplist-api-client-go/ent/user"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
)

// ShoppingCreate is the builder for creating a Shopping entity.
type ShoppingCreate struct {
	config
	date     *time.Time
	sum      *int
	complete *bool
	item     map[int]struct{}
	shop     map[int]struct{}
	user     map[int]struct{}
}

// SetDate sets the date field.
func (sc *ShoppingCreate) SetDate(t time.Time) *ShoppingCreate {
	sc.date = &t
	return sc
}

// SetNillableDate sets the date field if the given value is not nil.
func (sc *ShoppingCreate) SetNillableDate(t *time.Time) *ShoppingCreate {
	if t != nil {
		sc.SetDate(*t)
	}
	return sc
}

// SetSum sets the sum field.
func (sc *ShoppingCreate) SetSum(i int) *ShoppingCreate {
	sc.sum = &i
	return sc
}

// SetNillableSum sets the sum field if the given value is not nil.
func (sc *ShoppingCreate) SetNillableSum(i *int) *ShoppingCreate {
	if i != nil {
		sc.SetSum(*i)
	}
	return sc
}

// SetComplete sets the complete field.
func (sc *ShoppingCreate) SetComplete(b bool) *ShoppingCreate {
	sc.complete = &b
	return sc
}

// SetNillableComplete sets the complete field if the given value is not nil.
func (sc *ShoppingCreate) SetNillableComplete(b *bool) *ShoppingCreate {
	if b != nil {
		sc.SetComplete(*b)
	}
	return sc
}

// AddItemIDs adds the item edge to Item by ids.
func (sc *ShoppingCreate) AddItemIDs(ids ...int) *ShoppingCreate {
	if sc.item == nil {
		sc.item = make(map[int]struct{})
	}
	for i := range ids {
		sc.item[ids[i]] = struct{}{}
	}
	return sc
}

// AddItem adds the item edges to Item.
func (sc *ShoppingCreate) AddItem(i ...*Item) *ShoppingCreate {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return sc.AddItemIDs(ids...)
}

// SetShopID sets the shop edge to Shop by id.
func (sc *ShoppingCreate) SetShopID(id int) *ShoppingCreate {
	if sc.shop == nil {
		sc.shop = make(map[int]struct{})
	}
	sc.shop[id] = struct{}{}
	return sc
}

// SetNillableShopID sets the shop edge to Shop by id if the given value is not nil.
func (sc *ShoppingCreate) SetNillableShopID(id *int) *ShoppingCreate {
	if id != nil {
		sc = sc.SetShopID(*id)
	}
	return sc
}

// SetShop sets the shop edge to Shop.
func (sc *ShoppingCreate) SetShop(s *Shop) *ShoppingCreate {
	return sc.SetShopID(s.ID)
}

// SetUserID sets the user edge to User by id.
func (sc *ShoppingCreate) SetUserID(id int) *ShoppingCreate {
	if sc.user == nil {
		sc.user = make(map[int]struct{})
	}
	sc.user[id] = struct{}{}
	return sc
}

// SetNillableUserID sets the user edge to User by id if the given value is not nil.
func (sc *ShoppingCreate) SetNillableUserID(id *int) *ShoppingCreate {
	if id != nil {
		sc = sc.SetUserID(*id)
	}
	return sc
}

// SetUser sets the user edge to User.
func (sc *ShoppingCreate) SetUser(u *User) *ShoppingCreate {
	return sc.SetUserID(u.ID)
}

// Save creates the Shopping in the database.
func (sc *ShoppingCreate) Save(ctx context.Context) (*Shopping, error) {
	if sc.date == nil {
		v := shopping.DefaultDate()
		sc.date = &v
	}
	if sc.sum == nil {
		v := shopping.DefaultSum
		sc.sum = &v
	}
	if sc.complete == nil {
		v := shopping.DefaultComplete
		sc.complete = &v
	}
	if len(sc.shop) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"shop\"")
	}
	if len(sc.user) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"user\"")
	}
	return sc.sqlSave(ctx)
}

// SaveX calls Save and panics if Save returns an error.
func (sc *ShoppingCreate) SaveX(ctx context.Context) *Shopping {
	v, err := sc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (sc *ShoppingCreate) sqlSave(ctx context.Context) (*Shopping, error) {
	var (
		s     = &Shopping{config: sc.config}
		_spec = &sqlgraph.CreateSpec{
			Table: shopping.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: shopping.FieldID,
			},
		}
	)
	if value := sc.date; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: shopping.FieldDate,
		})
		s.Date = *value
	}
	if value := sc.sum; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: shopping.FieldSum,
		})
		s.Sum = *value
	}
	if value := sc.complete; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  *value,
			Column: shopping.FieldComplete,
		})
		s.Complete = *value
	}
	if nodes := sc.item; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   shopping.ItemTable,
			Columns: []string{shopping.ItemColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: item.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := sc.shop; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   shopping.ShopTable,
			Columns: []string{shopping.ShopColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: shop.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := sc.user; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   shopping.UserTable,
			Columns: []string{shopping.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if err := sqlgraph.CreateNode(ctx, sc.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	id := _spec.ID.Value.(int64)
	s.ID = int(id)
	return s, nil
}
